const { log } = require('console');


plugin.consumes = ['cli', 'workspace', 'Log', 'device_manager', 'process_manager', 'crash', 'nodejs', 'doctor', 'config', 'globals', 'platform'];
plugin.provides = ['commands'];

function plugin(imports, register) {
    var { cli, workspace, Log, device_manager, process_manager, crash, nodejs, doctor, config, globals, platform } = imports;
    const EventEmitter = nodejs.events.EventEmitter;
    const fs = nodejs.fs;
    const path = nodejs.path;
    const { run, tryRun } = process_manager

    let _PROCESS_EXIT_CODE = 0;
    let _BUILD_ONLY = false;

    const processStartTime = Date.now();

    function onCrashDetected() {

    }

    let testTarget = null;
    cli('--test-target')
        .flags({ pre: true })
        .info('Start the metro development server')
        .do((values) => {
            try {
                const v = values && values['--test-target'];
                if (v) testTarget = String(v);
            } catch (_) { }
        });
    
    let crashCheck = true;
    cli('--disable-crash-check')
        .flags({ pre: true })
        .info('Disable crash detection check')
        .do(() => {
            crashCheck = false;
        });
    function generateTestList() {
        try {
            const testsDir = path.join(workspace.path, '__e2e_tests__');
            if (!fs.existsSync(testsDir)) {
                try { (Log && Log.out) ? Log.out('[TEST LIST] no __e2e_tests__ folder, skipping') : console.log('[TEST LIST] no __e2e_tests__ folder, skipping'); } catch(_){}
                return;
            }

            const files = fs.readdirSync(testsDir).filter(f => {
                if(testTarget && !f.includes(testTarget)) return false;
                if (!f || !f.endsWith('.js')) return false;
                if (f === 'index.js') return false;
                return true;
            });
            const indexPath = path.join(testsDir, 'index.js');

            let content;
            if (!files || files.length === 0) {
                content = 'module.exports = [];\n';
            } else {
                const requires = files.map(f => `require('./${f.replace(/\\/g, '/') }')`).join(',\n    ');
                content = '// Auto-generated by test-moniker CLI. Do not edit.\nmodule.exports = [\n    ' + requires + '\n];\n';
            }

            let old = null;
            try { if (fs.existsSync(indexPath)) old = fs.readFileSync(indexPath, 'utf8'); } catch(_) { old = null; }
            if (old === content) {
                try { (Log && Log.out) ? Log.out('[TEST LIST] up-to-date: ' + indexPath) : console.log('[TEST LIST] up-to-date: ' + indexPath); } catch(_){}
                return;
            }

            fs.writeFileSync(indexPath, content, 'utf8');
            try { (Log && Log.out) ? Log.out('[TEST LIST] generated ' + indexPath) : console.log('[TEST LIST] generated ' + indexPath); } catch(_){}
        } catch (e) {
            try { (Log && Log.err) ? Log.err('[TEST LIST] error: ' + e.message) : console.error('[TEST LIST] error: ' + e.message); } catch(_){}
        }
    }

    const exitProcess = (code) => {
        Log.out('Process ran for ' + ((Date.now() - processStartTime) / 1000) + ' seconds. exit code: ' + code);
        Log.out('Initial command: `npx test-moniker ' + process.argv.slice(2).join(' ') + '`');
        Log.out('Logs saved to ' + Log.path);
        //save Log.path to logs/latest-log.txt
        try {
            const latestLogPath = path.join(globals.workspace, 'logs', 'latest-log.txt');
            fs.writeFileSync(latestLogPath, Log.path, 'utf8');
        } catch (_) { }
        process.exit(code);
    }

    var processes = {};


    cli('--build-only', '-b')
        .flags({ pre: true })
        .info('Start the metro development server')
        .do(() => {
            _BUILD_ONLY = true;
        });

    cli('--start-dev-server', '-s')
        .info('Start the metro development server')
        .do(() => {
            const _doctor = doctor.get();
            // console.log(_doctor)
            // process.exit(0);
            const { out, err } = Log;
            // show this process command line arguments that was used to start CLI using process.argv ( but not the first two args)


            let metro, _builder, logcat, crashDetected = false;
            if(_doctor.metro_port_8081 == 'in-use') {
                if(platform && platform.isLinux)
                    tryRun('fuser', ['-k', '8081/tcp']);//kill any process using metro port
                if(platform && platform.isWindows)
                    tryRun('powershell', ['-Command', 'Stop-Process -Id (Get-NetTCPConnection -LocalPort 8081).OwningProcess -Force']);
            }

            generateTestList();

            metro = startMeroServer();

            metro.on('ready', () => {
                _builder = buildAndInstall();
                _builder.on('opening', (error) => {
                    if (_BUILD_ONLY) {
                        _PROCESS_EXIT_CODE = 0;
                        metro.process.stop();
                        return;
                    }
                    logcat = adbLogCat();
                    logcat.on('crash', (serial, line) => {
                        if (crashDetected) return;
                        crashDetected = true;
                        try { _PROCESS_EXIT_CODE = 1; } catch (_) { }
                        metro.process.stop();


                        // capture bugreport on crash keywords
                        try {
                            if (crash.capture_enabled) {
                                try {
                                    err('[CRASH HANDLER] on device ' + serial + ': ' + line);
                                    //kill app package id before running bugreport
                                    try {
                                        // compute app package id based on the same logic used in `doctor`
                                        let appPkg = null;
                                        try {
                                            const fs = require('fs');
                                            const path = require('path');
                                            const appJsonPath = path.join(workspace.path, 'app.json');
                                            if (fs.existsSync(appJsonPath)) {
                                                const raw = fs.readFileSync(appJsonPath, 'utf8');
                                                try {
                                                    const obj = JSON.parse(raw);
                                                    if (obj && obj.expo && obj.expo.android && obj.expo.android.package) appPkg = obj.expo.android.package;
                                                    else if (obj && obj.expo && obj.expo.package) appPkg = obj.expo.package;
                                                } catch (_) { }
                                            }
                                        } catch (_) { }
                                        if (!appPkg) {
                                            try {
                                                const fs = require('fs');
                                                const path = require('path');
                                                const manifest = path.join(workspace.path, 'android', 'app', 'src', 'main', 'AndroidManifest.xml');
                                                if (fs.existsSync(manifest)) {
                                                    const raw = fs.readFileSync(manifest, 'utf8');
                                                    const m = raw.match(/package=\"([^\"]+)\"/);
                                                    if (m) appPkg = m[1];
                                                }
                                            } catch (_) { }
                                        }
                                        if (appPkg) {
                                            err('[CRASH HANDLER] Stopping app ' + appPkg + ' on device ' + serial + '...');
                                            const stopRes = device_manager.safeExec('adb', ['-s', serial, 'shell', 'am', 'force-stop', appPkg]);
                                            err('[CRASH HANDLER] Stopped app result: ' + (stopRes && stopRes.ok ? 'ok' : ('failed: ' + (stopRes.stderr || stopRes.stdout || '~UNKNOWN'))));
                                        }
                                    } catch (_) { }

                                    err('[CRASH HANDLER] Capturing bugreport for device ' + serial + '... This could take a while.');
                                    // const ts = Date.now();
                                    // const fs = require('fs');
                                    const path = require('path');
                                    const logDir = (Log && Log.path) ? path.join(workspace.path, path.dirname(Log.path)) : path.join(workspace.path, 'logs');
                                    // try { if (!fs.existsSync(logDir)) fs.mkdirSync(logDir, { recursive: true }); } catch (_) {}
                                    // const outPath = path.join(logDir, 'bugreport-' + ts );
                                    err('[CRASH HANDLER] Saving bugreport to folder ' + logDir);
                                    device_manager.captureBugreport(logDir, serial, (crasRes) => {
                                        let ol = '[CRASH HANDLER] Captured bugreport: ' + (crasRes && crasRes.output ? crasRes.output : outPath);
                                        // try { err(ol); } catch (_) { console.log(ol); }
                                        try { if (out) out(ol); } catch (_) { }
                                        try { logcat.stop(); } catch (_) { }
                                    });
                                } catch (_) { }
                            } else {
                                Log.out('Crash detected, but crash capturing is disabled.');
                                Log.out('Run --capture-bugreport-on-crash to enable crash capturing.');
                                // stopping log cat will stop metro
                                logcat.stop();
                            }
                        } catch (_) { }
                    });
                    logcat.on('done', () => {
                        if (crashDetected) exitProcess(_PROCESS_EXIT_CODE);//exit when crashDetected detected
                        else metro.process.stop();
                    })
                })
                _builder.on('failed', (error) => {
                    _PROCESS_EXIT_CODE = 1;
                    err('Build server error: (see logs for details)');
                    metro.process.stop();
                });
                _builder.on('close', (code) => {
                    if (code == 1) {
                        _PROCESS_EXIT_CODE = 1;
                        err('Build server error: (see logs for details)');
                        metro.process.stop();
                        if (logcat) logcat.stop();
                    }
                });
            });
            metro.on('close', () => {
                if (!crashDetected)
                    exitProcess(_PROCESS_EXIT_CODE);//exit when metro stops
            });

            metro.on('done', (lineData) => {
                // line data ` LOG  [Moniker] TEST COMPLETE | Passed: 2 Failed: 1 (3.05s)`
                try {
                    const passedMatch = lineData.match(/Passed:\s*(\d+)/);
                    const failedMatch = lineData.match(/Failed:\s*(\d+)/);
                    let passed = 0, failed = 0;
                    if (passedMatch) passed = parseInt(passedMatch[1] || '0');
                    if (failedMatch) failed = parseInt(failedMatch[1] || '0');
                    if (failed > 0) _PROCESS_EXIT_CODE = 1;
                    else _PROCESS_EXIT_CODE = 0;
                } catch (_) { }

                logcat.stop();
            });

            metro.on('error', (error) => {
                err('Metro server error:', error);
                logcat.stop();
                metro.process.stop();
            });
        });


    function startMeroServer(ready, close, done, error) {
        const { out, err } = Log;
        const metro = process_manager('metro');
        const $metro = new EventEmitter();
        $metro.process = metro;

        metro.setup('npx', ['expo', 'start', '--dev-client'], { cwd: workspace.path, stdio: 'pipe' });

        let metroBuf = '';

        function logger(chunk) {
            try {
                const data = chunk.toString();
                if (data.includes('Waiting on http')) {
                    if (ready) ready();
                    $metro.emit('ready');
                }
                if (data.includes('TEST COMPLETE')) {
                    if (done) done(data);
                    $metro.emit('done', data);
                }
                if (data.includes('ERROR  SyntaxError')) {
                    if (error) error(data);
                    $metro.emit('error', data);
                }
                metroBuf += data;
                const lines = metroBuf.split(/\r?\n/);
                metroBuf = lines.pop();
                for (let i = 0; i < lines.length; i++) {
                    const line = '[METRO] ' + lines[i];
                    out(line);
                }
            } catch (_) { }
        }

        metro.on('stdout', (chunk) => logger(chunk));

        metro.on('close', (code) => {
            if (code)
                out(`Metro server exited with code ${code}`);
            if (close) close(code);
            $metro.emit('close', code);
        });

        metro.start();

        return $metro;
    }

    function buildAndInstall(ready, close, _installed, open, failed) {
        const { out, err } = Log;
        const builder = process_manager('builder');
        const $builder = new EventEmitter();
        $builder.process = builder;

        builder.setup('npx', ['expo', 'run:android', '--no-bundler'], { cwd: workspace.path, stdio: 'pipe' });
        let installed = false;
        let opening = false;

        let builderBuf = '';
        function logger(data) {
            const chunk = data.toString();
            builderBuf += chunk;
            const lines = builderBuf.split(/\r?\n/);
            builderBuf = lines.pop();
            for (let i = 0; i < lines.length; i++) {
                const line = '[BUILD] ' + lines[i];
                out(line);
            }
        }

        builder.on('stdout', (data) => {
            try {
                const s = String(data);
                if (s.includes('Installing')) {
                    installed = true;
                    if (_installed) _installed();
                    $builder.emit('installed');
                }
                if (s.includes('Opening')) {
                    opening = true;
                    if (open) open();
                    $builder.emit('opening');
                }
                if (s.includes('BUILD FAILED')) {
                    err('Build failed');
                    if (failed) failed();
                    $builder.emit('failed');
                }
                logger(data);
            } catch (_) { err(_); }
        });
        builder.on('stderr', (data) => {
            try {
                logger(data);
            } catch (_) { err(_); }
        });


        builder.on('close', (code) => {
            if (code)
                out(`Builder exited with code ${code}`);
            if (close) close(code);
            if (ready) ready(installed && opening);
            $builder.emit('close', code);
            $builder.emit('ready', installed && opening);
        });

        builder.start();
        return $builder;
    }

    function adbLogCat(done, crashDetect) {

        const _config = config.get();

        const $logCat = new EventEmitter();
        const { out, err } = Log;
        // New, simpler adb log collector per-device.
        const fs = require('fs');
        const path = require('path');

        // resolve app package id (app.json or AndroidManifest)
        let appPackage = null;
        try {
            const appJsonPath = path.join(workspace.path, 'app.json');
            if (fs.existsSync(appJsonPath)) {
                const raw = fs.readFileSync(appJsonPath, 'utf8');
                try {
                    const obj = JSON.parse(raw);
                    if (obj && obj.expo && obj.expo.android && obj.expo.android.package) appPackage = obj.expo.android.package;
                    else if (obj && obj.expo && obj.expo.package) appPackage = obj.expo.package;
                } catch (_) { }
            }
            if (!appPackage) {
                const manifest = path.join(workspace.path, 'android', 'app', 'src', 'main', 'AndroidManifest.xml');
                if (fs.existsSync(manifest)) {
                    const raw = fs.readFileSync(manifest, 'utf8');
                    const m = raw.match(/package=\"([^\"]+)\"/);
                    if (m) appPackage = m[1];
                }
            }
        } catch (_) { appPackage = null; }

        const devices = Array.isArray(device_manager.listDevices && device_manager.listDevices()) ? device_manager.listDevices() : (device_manager.listDevices() || []);
        const collectors = [];
        let closed = 0;

        function makeCollector(serial) {
            // clear logcat buffer first
            try { device_manager.safeExec('adb', ['-s', serial, 'logcat', '-c']); } catch (_) { }

            // try pidof, but tolerate failures
            let pid = null;
            if (appPackage) {
                try {
                    const r = device_manager.safeExec('adb', ['-s', serial, 'shell', 'pidof', appPackage]);
                    if (r && r.ok && r.stdout) pid = (r.stdout || '').trim().split(/\s+/)[0] || null;
                } catch (_) { pid = null; }
            }

            const name = 'logcat-' + serial;
            const proc = process_manager(name);
            // Start unfiltered logcat (with timestamps) so we don't miss native crash signals.
            // If pid is available prefer pid filtering to reduce noise; otherwise capture all tags.
            const args = ['-s', serial, 'logcat', '-v', 'time'];
            if (pid) {
                args.push('--pid', pid);
            }

            // Silence very noisy system tags observed during short captures.
            // These were determined by sampling raw `adb logcat -v time` and
            // represent frequent system noise we generally don't need in device logs.
            const NOISY_TAGS = _config.noisyTags || [];
            for (const t of NOISY_TAGS) {
                try { args.push(t + ':S'); } catch (_) { }
            }

            proc.setup('adb', args, { stdio: 'pipe' });

            let buffer = '';
            const onData = (data) => {
                buffer += data.toString();
                const parts = buffer.split(/\r?\n/);
                buffer = parts.pop();
                for (const line of parts) {
                    if (!line) continue;
                    out('[ADB-' + serial + '] ' + line);
                    // capture bugreport on crash keywords
                    try {
                        if (crashCheck && (line.includes('FATAL EXCEPTION') || line.includes('SIGSEGV') || line.includes('ANR') || line.includes('Fatal signal'))) {
                            //stop log cat, no longer needed
                            crashDetect && crashDetect(serial, line);
                            $logCat.emit('crash', serial, line);
                        }
                    } catch (_) { }
                }
            };

            proc.on('stdout', onData);
            proc.on('stderr', onData);
            proc.on('close', (code) => {
                if (code)
                    out(`adb logcat(${serial}) exited with code ${code}`);
                closed++;
                if (closed === collectors.length) {
                    if (done) done(code)
                    $logCat.emit('done', code);
                };
            });

            proc.start();
            return proc;
        }

        // start collectors for each device
        for (const d of devices) {
            const serial = d && d.serial;
            if (!serial) continue;
            const c = makeCollector(serial);
            collectors.push(c);
        }

        $logCat.stop = function () {
            for (const p of collectors) {
                try { p.stop(); } catch (_) { }
            }
        }
        return $logCat;
    }

    register(null, {
        commands: {
            startMeroServer,
            buildAndInstall,
            adbLogCat
        }
    });
}


module.exports = plugin;
